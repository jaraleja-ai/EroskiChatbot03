#!/usr/bin/env python3
# =====================================================
# test_classify_node.py - Script de Prueba para Nodo Classify
# =====================================================
"""
Script interactivo para probar el nodo classify de forma aislada.

FUNCIONALIDAD:
- Simula estado post-autenticaci√≥n con datos del empleado
- Incluye historial inicial de mensajes
- Permite conversaci√≥n interactiva
- Muestra estado interno del nodo en cada iteraci√≥n
- Maneja escalaciones y finalizaciones

EJECUCI√ìN:
python test_classify_node.py

COMANDOS ESPECIALES:
- 'quit' o 'exit': Salir del script
- 'state': Mostrar estado completo actual
- 'reset': Reiniciar conversaci√≥n
- 'debug': Activar/desactivar modo debug
"""

import asyncio
import sys
import json
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

# Agregar el directorio ra√≠z del proyecto al path
sys.path.insert(0, str(Path(__file__).parent))

from langchain_core.messages import AIMessage, HumanMessage
from models.eroski_state import EroskiState


# =============================================================================
# CONFIGURACI√ìN DE LOGGING
# =============================================================================

def setup_logging(debug_mode: bool = False):
    """Configurar logging para el test"""
    level = logging.DEBUG if debug_mode else logging.INFO
    
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )
    
    # Reducir ruido de otros loggers
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("openai").setLevel(logging.WARNING)


# =============================================================================
# DATOS DE PRUEBA INICIALES
# =============================================================================

def create_initial_state() -> EroskiState:
    """
    Crear estado inicial simulando que viene del nodo de autenticaci√≥n.
    
    Incluye:
    - Datos del empleado autenticado
    - Historial de mensajes de la autenticaci√≥n
    - Estado completo para clasificaci√≥n
    """
    
    # Historial de mensajes de la fase de autenticaci√≥n
    messages = [
        HumanMessage(content="hola, tengo un problema con la balanza"),
        AIMessage(content="Hola! Veo que tienes un problema con una balanza. Para ayudarte necesito verificar algunos datos. ¬øPodr√≠as decirme tu nombre completo?"),
        HumanMessage(content="Javier Guerra"),
        AIMessage(content="Perfecto, Javier. ¬øCu√°l es tu email corporativo?"),
        HumanMessage(content="javier.guerra@devol.es, tienda de Eroski en el centro de Bilbao"),
        AIMessage(content="Entiendo que trabajas en Eroski del centro de Bilbao. ¬øEn qu√© secci√≥n espec√≠fica trabajas?"),
        HumanMessage(content="esta en la secci√≥n de carnicer√≠a"),
        AIMessage(content="Perfecto, Javier. Ya tengo todos tus datos:\n- Nombre: Javier Guerra\n- Email: javier.guerra@devol.es\n- Tienda: Eroski Bilbao Centro\n- Secci√≥n: Carnicer√≠a\n\nAhora vamos a analizar el problema con la balanza. ¬øPodr√≠as contarme m√°s detalles sobre qu√© est√° ocurriendo?")
    ]
    
    # Estado completo
    state = EroskiState(
        # Identificaci√≥n de sesi√≥n
        session_id="test_classify_session_123",
        user_id="javier.guerra@devol.es",
        
        # Estado de autenticaci√≥n (COMPLETADO)
        authenticated=True,
        auth_data_collected={
            "name": "Javier Guerra",
            "email": "javier.guerra@devol.es",
            "store_name": "Eroski Bilbao Centro",
            "section": "Carnicer√≠a",
            "store_code": "ERBIL001",
            "authenticated_at": datetime.now().isoformat()
        },
        authentication_completed=True,
        
        # Historial de mensajes
        messages=messages,
        
        # Estado actual del workflow
        current_step="classify",
        
        # Datos de clasificaci√≥n (INICIALES - para que el nodo empiece desde cero)
        classify_data={},
        classify_attempt_number=0,
        classification_completed=False,
        
        # Metadata
        conversation_started_at=datetime.now().isoformat(),
        last_activity=datetime.now().isoformat()
    )
    
    return state


# =============================================================================
# CLASE PRINCIPAL DE TESTING
# =============================================================================

class ClassifyNodeTester:
    """
    Tester interactivo para el nodo classify.
    """
    
    def __init__(self, debug_mode: bool = False):
        self.debug_mode = debug_mode
        self.state = create_initial_state()
        self.node = None
        
        setup_logging(debug_mode)
        self.logger = logging.getLogger("ClassifyTester")
        
    async def initialize(self):
        """Inicializar el nodo de clasificaci√≥n"""
        try:
            # Importar din√°micamente el nodo
            from nodes.classify_llm_driven import LLMDrivenClassifyNode
            self.node = LLMDrivenClassifyNode()
            
            self.logger.info("‚úÖ Nodo classify inicializado correctamente")
            
            # Verificar que se carguen los tipos de incidencia
            incident_count = len(self.node.incident_types)
            self.logger.info(f"üìã Tipos de incidencia cargados: {incident_count}")
            
            if incident_count == 0:
                self.logger.warning("‚ö†Ô∏è No se cargaron tipos de incidencia. Verificar archivo JSON.")
            
        except ImportError as e:
            self.logger.error(f"‚ùå Error importando nodo: {e}")
            self.logger.error("Verifica que el archivo nodes/classify_llm_driven.py exista")
            return False
        except Exception as e:
            self.logger.error(f"‚ùå Error inicializando nodo: {e}")
            return False
        
        return True
    
    def print_welcome(self):
        """Mostrar mensaje de bienvenida"""
        print("\n" + "="*80)
        print("üß™ TESTER INTERACTIVO PARA NODO CLASSIFY")
        print("="*80)
        print(f"üë§ Empleado: {self.state['auth_data_collected']['name']}")
        print(f"üìß Email: {self.state['auth_data_collected']['email']}")
        print(f"üè™ Tienda: {self.state['auth_data_collected']['store_name']}")
        print(f"üîß Secci√≥n: {self.state['auth_data_collected']['section']}")
        print("-"*80)
        print("üí¨ HISTORIAL INICIAL (que el nodo analizar√°):")
        self._print_message_history()
        print("-"*80)
        print("üß† INFORMACI√ìN PARA EL AN√ÅLISIS:")
        print("  ‚Ä¢ El usuario YA mencion√≥ 'problema con la balanza' en el primer mensaje")
        print("  ‚Ä¢ El nodo debe DETECTAR esto autom√°ticamente")
        print("  ‚Ä¢ NO debe pedir que repita informaci√≥n ya proporcionada")
        print("  ‚Ä¢ Debe ser m√°s espec√≠fico en sus preguntas")
        print("-"*80)
        print("üéÆ COMANDOS ESPECIALES:")
        print("  ‚Ä¢ 'quit' o 'exit' - Salir")
        print("  ‚Ä¢ 'state' - Mostrar estado completo")
        print("  ‚Ä¢ 'reset' - Reiniciar conversaci√≥n")
        print("  ‚Ä¢ 'debug' - Alternar modo debug")
        print("  ‚Ä¢ 'codigo' - Mostrar c√≥digo de incidencia")
        print("="*80)
        print("\nüöÄ El nodo va a analizar autom√°ticamente el historial...")
        print("üí° Observa c√≥mo detecta 'problema con la balanza' del primer mensaje")
        print("üéØ Deber√≠a hacer preguntas espec√≠ficas sobre balanzas, no gen√©ricas")
        
        # ‚úÖ NUEVO: Mostrar c√≥digo de incidencia si existe
        incident_code = self.state.get("incident_code")
        if incident_code:
            print(f"\nüìã C√≥digo de incidencia activo: {incident_code}")
        print()
    
    def _print_message_history(self, limit: int = None):
        """Imprimir historial de mensajes"""
        messages = self.state.get("messages", [])
        
        if limit:
            messages = messages[-limit:]
        
        for i, msg in enumerate(messages):
            if isinstance(msg, HumanMessage):
                print(f"  üë§ Usuario: {msg.content}")
            elif isinstance(msg, AIMessage):
                print(f"  ü§ñ Bot: {msg.content}")
    
    def _print_classify_state(self):
        """Mostrar estado actual de clasificaci√≥n"""
        classify_data = self.state.get("classify_data", {})
        
        print("\nüìä ESTADO DE CLASIFICACI√ìN:")
        print("-"*50)
        print(f"  Incidencia identificada: {classify_data.get('incident_identified', False)}")
        print(f"  Problema identificado: {classify_data.get('problem_identified', False)}")
        print(f"  Soluci√≥n lista: {classify_data.get('solution_ready', False)}")
        print(f"  Confianza: {classify_data.get('confidence_level', 0.0):.2f}")
        print(f"  Historial confianza: {classify_data.get('confidence_history', [])}")
        print(f"  Evaluaci√≥n progreso: {classify_data.get('progress_assessment', 'N/A')}")
        print(f"  Nueva informaci√≥n: {classify_data.get('new_information_provided', False)}")
        print(f"  En bucle: {classify_data.get('stuck_in_loop', False)}")
        print(f"  Tipo: {classify_data.get('incident_type', 'N/A')}")
        print(f"  Problema espec√≠fico: {classify_data.get('specific_problem', 'N/A')}")
        print(f"  Intentos: {self.state.get('classify_attempt_number', 0)}")
        print(f"  Keywords detectadas: {classify_data.get('keywords_detected', [])}")
        print(f"  Nivel urgencia: {classify_data.get('urgency_level', 'N/A')}")
        print(f"  Info hist√≥rica: {classify_data.get('historical_info_found', 'N/A')}")
        print(f"  Fuente soluci√≥n: {classify_data.get('solution_source', 'N/A')}")
        print(f"  Clasificaci√≥n autom√°tica: {classify_data.get('auto_classify_attempted', False)}")
        print(f"  Esperando confirmaci√≥n: {classify_data.get('awaiting_confirmation', False)}")
        print(f"  Soluci√≥n exitosa: {classify_data.get('solution_successful', 'N/A')}")
        print("-"*50)
    
    def _print_full_state(self):
        """Mostrar estado completo (para debugging)"""
        print("\nüîç ESTADO COMPLETO:")
        print("-"*70)
        
        # Estado de alto nivel
        print(f"Session ID: {self.state.get('session_id')}")
        print(f"Autenticado: {self.state.get('authenticated')}")
        print(f"Paso actual: {self.state.get('current_step')}")
        print(f"Clasificaci√≥n completa: {self.state.get('classification_completed')}")
        
        # Datos de autenticaci√≥n
        auth_data = self.state.get("auth_data_collected", {})
        print(f"\nDatos autenticaci√≥n: {json.dumps(auth_data, indent=2, ensure_ascii=False)}")
        
        # Estado de clasificaci√≥n
        self._print_classify_state()
        
        # √öltimos 3 mensajes
        print("\nüí¨ √öLTIMOS MENSAJES:")
        self._print_message_history(limit=3)
        
        print("-"*70)
    
    async def process_user_input(self, user_input: str) -> bool:
        """
        Procesar entrada del usuario y ejecutar el nodo.
        
        Returns:
            True si debe continuar, False si debe salir
        """
        
        # Comandos especiales
        if user_input.lower() in ['quit', 'exit']:
            return False
        
        if user_input.lower() == 'state':
            self._print_full_state()
            return True
        
        if user_input.lower() == 'reset':
            self.state = create_initial_state()
            print("\nüîÑ Estado reiniciado")
            return True
        
        if user_input.lower() == 'debug':
            self.debug_mode = not self.debug_mode
            setup_logging(self.debug_mode)
            print(f"\nüêõ Modo debug: {'ON' if self.debug_mode else 'OFF'}")
            return True
        
        if user_input.lower() in ['codigo', 'c√≥digo']:
            incident_code = self.state.get("incident_code", "No asignado")
            print(f"\nüìã C√≥digo de incidencia: {incident_code}")
            return True
        
        # Agregar mensaje del usuario al estado
        self.state["messages"].append(HumanMessage(content=user_input))
        self.state["last_activity"] = datetime.now().isoformat()
        
        try:
            # Ejecutar el nodo
            print("\nü§ñ Procesando...")
            
            command = await self.node.execute(self.state)
            
            # Aplicar actualizaciones
            self.state.update(command.update)
            
            # Mostrar respuesta del bot
            messages = self.state.get("messages", [])
            if messages and isinstance(messages[-1], AIMessage):
                bot_response = messages[-1].content
                print(f"\nü§ñ Bot: {bot_response}")
                
                # ‚úÖ NUEVO: Mostrar c√≥digo de incidencia en lateral
                incident_code = self.state.get("incident_code")
                if incident_code:
                    print(f"\n{'':>60}üìã C√≥digo: {incident_code}")
            
            # Mostrar estado de clasificaci√≥n si est√° en debug
            if self.debug_mode:
                self._print_classify_state()
            
            # Verificar si se complet√≥ o escal√≥
            current_step = self.state.get("current_step")
            if current_step == "escalate":
                print("\nüîù ESCALACI√ìN ACTIVADA - Conversaci√≥n derivada a supervisor")
                return False
            elif self.state.get("classification_completed"):
                print("\n‚úÖ CLASIFICACI√ìN COMPLETADA")
                self._print_classify_state()
                return False
            elif self.state.get("conversation_ended"):
                print("\nüîö CONVERSACI√ìN FINALIZADA - Problema resuelto")
                return False
            elif self.state.get("classify_data", {}).get("awaiting_confirmation"):
                print("\n‚è≥ ESPERANDO CONFIRMACI√ìN DEL USUARIO")
                print("üí° Responde 's√≠' si funcion√≥ o 'no' si persiste el problema")
                return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error ejecutando nodo: {e}")
            if self.debug_mode:
                import traceback
                traceback.print_exc()
            print(f"\nüí• Error: {e}")
        
        return True
    
    async def run_interactive_session(self):
        """Ejecutar sesi√≥n interactiva"""
        
        if not await self.initialize():
            print("‚ùå No se pudo inicializar el nodo. Abortando.")
            return
        
        self.print_welcome()
        
        try:
            while True:
                # Solicitar input del usuario
                user_input = input("\nüë§ T√∫: ").strip()
                
                if not user_input:
                    continue
                
                # Procesar input
                should_continue = await self.process_user_input(user_input)
                
                if not should_continue:
                    break
                    
        except KeyboardInterrupt:
            print("\n\n‚èπÔ∏è Sesi√≥n interrumpida por el usuario")
        except Exception as e:
            print(f"\nüí• Error inesperado: {e}")
        
        print("\nüëã ¬°Hasta luego!")


# =============================================================================
# FUNCI√ìN PRINCIPAL
# =============================================================================

async def main():
    """Funci√≥n principal del script"""
    
    # Parsear argumentos simples
    debug_mode = '--debug' in sys.argv or '-d' in sys.argv
    
    if '--help' in sys.argv or '-h' in sys.argv:
        print(__doc__)
        return
    
    # Crear y ejecutar tester
    tester = ClassifyNodeTester(debug_mode=debug_mode)
    await tester.run_interactive_session()


# =============================================================================
# SCRIPT PARA TESTING R√ÅPIDO (NO INTERACTIVO)
# =============================================================================

async def quick_test():
    """Test r√°pido no interactivo para verificar funcionamiento b√°sico"""
    
    print("üöÄ EJECUTANDO TEST R√ÅPIDO...")
    
    # Crear tester
    tester = ClassifyNodeTester(debug_mode=True)
    
    # Inicializar
    if not await tester.initialize():
        print("‚ùå Fallo en inicializaci√≥n")
        return
    
    # Mensajes de prueba
    test_messages = [
        "La balanza no imprime etiquetas",
        "S√≠, tiene papel pero a√∫n as√≠ no imprime",
        "¬øDeber√≠a reiniciarla?"
    ]
    
    print(f"\nüìù Probando con {len(test_messages)} mensajes...")
    
    for i, msg in enumerate(test_messages, 1):
        print(f"\n--- TEST {i}/{len(test_messages)} ---")
        print(f"üë§ Input: {msg}")
        
        should_continue = await tester.process_user_input(msg)
        
        if not should_continue:
            print("üõë Test terminado prematuramente")
            break
    
    print("\n‚úÖ Test r√°pido completado")


# =============================================================================
# PUNTO DE ENTRADA
# =============================================================================

if __name__ == "__main__":
    
    if '--quick' in sys.argv:
        # Test r√°pido no interactivo
        asyncio.run(quick_test())
    else:
        # Sesi√≥n interactiva completa
        asyncio.run(main())