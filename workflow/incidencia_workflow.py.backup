# =====================================================
# workflow/incidencia_workflow.py - ROUTER HÍBRIDO ACTUALIZADO
# =====================================================
from langgraph.graph import StateGraph, START, END
from workflow.base_workflow import BaseWorkflow
from models.state import GraphState
from typing import Dict, Any
import logging

# ✅ IMPORTS LIMPIOS - SIN DUPLICACIONES
from nodes.identificar_usuario import identificar_usuario_node
from nodes.procesar_incidencia import procesar_incidencia_node
from nodes.escalar_supervisor import escalar_supervisor_node
from nodes.finalizar_ticket import finalizar_ticket_node
from nodes.interrupcion_identificar_usuario import interrupcion_identificar_usuario

class IncidenciaWorkflow(BaseWorkflow):
    """
    🎭 WORKFLOW HÍBRIDO ACTUALIZADO: LangGraph + Actor Pattern
    
    NUEVAS CARACTERÍSTICAS:
    - ✅ Interrupciones centralizadas SOLO en interrupcion_identificar_usuario
    - ✅ Router que respeta señales de actores ANTES de decidir
    - ✅ Estado siempre actualizado cuando llega al router
    - ✅ Sin bucles infinitos por diseño
    
    PRINCIPIOS HÍBRIDOS:
    - ✅ Estructura LangGraph para el framework
    - ✅ Decisiones autónomas de actores
    - ✅ Router que RESPETA las señales de actores
    - ✅ Manejo de interrupciones centralizadas
    
    ROUTER INTELIGENTE ACTUALIZADO:
    - Los actores DECIDEN, el router solo EJECUTA
    - Prioriza señales explícitas de actores
    - Centraliza interrupciones en interrupcion_identificar_usuario
    - Fallback inteligente sin bucles
    """
    
    def __init__(self):
        super().__init__("IncidenciaWorkflow")
    
    def build_graph(self) -> StateGraph:
        """Construir grafo híbrido con routing inteligente actualizado"""
        
        self.logger.info("🔧 Construyendo grafo híbrido actualizado...")
        
        # Crear grafo con el estado
        graph = StateGraph(GraphState)
        
        # ✅ AGREGAR TODOS LOS NODOS/ACTORES
        graph.add_node("identificar_usuario", identificar_usuario_node)
        graph.add_node("procesar_incidencia", procesar_incidencia_node) 
        graph.add_node("escalar_supervisor", escalar_supervisor_node)
        graph.add_node("finalizar_ticket", finalizar_ticket_node)
        graph.add_node("interrupcion_identificar_usuario", interrupcion_identificar_usuario)  # ⭐ NODO DE INTERRUPCIONES
        
        # Punto de entrada
        graph.add_edge(START, "identificar_usuario")
        
        # ✅ ROUTING HÍBRIDO ACTUALIZADO - INCLUYE interrupcion_identificar_usuario
        self.routing_destinations = {
            "identificar_usuario": "identificar_usuario",
            "procesar_incidencia": "procesar_incidencia",
            "escalar_supervisor": "escalar_supervisor", 
            "finalizar_ticket": "finalizar_ticket",
            "interrupcion_identificar_usuario": "interrupcion_identificar_usuario",  # ⭐ INCLUIR EN DESTINOS
            END: END
        }
        
        # ✅ APLICAR ROUTING INTELIGENTE A TODOS LOS ACTORES QUE TOMAN DECISIONES
        decision_actors = [
            "identificar_usuario", 
            "procesar_incidencia", 
            "interrupcion_identificar_usuario"  # ⭐ INCLUIR PARA QUE PUEDA DIRIGIR DESPUÉS DE INTERRUPCIÓN
        ]
        
        for actor_name in decision_actors:
            self.add_conditional_edges(
                graph,
                actor_name,
                self._route_conversation,
                self.routing_destinations
            )
            self.logger.debug(f"🔀 Routing híbrido configurado para {actor_name}")
        
        # ✅ EDGES DIRECTOS PARA NODOS FINALES (sin decisiones complejas)
        graph.add_edge("escalar_supervisor", END)
        graph.add_edge("finalizar_ticket", END)
        
        self.logger.info("✅ Grafo híbrido actualizado construido exitosamente")
        return graph


    def _route_conversation(self, state: Dict[str, Any]) -> str:
        """
        🧠 ROUTER HÍBRIDO CORREGIDO - Lee señales de actores correctamente
        
        ORDEN DE PRIORIDADES:
        1. Señales explícitas de actores (_actor_decision)
        2. Estado awaiting_input (interrupciones)
        3. Estado de datos del usuario
        4. Escalación y finalización
        5. Fallback inteligente con protección anti-bucle
        """
        
        # 🔍 DEBUG COMPLETO DEL ESTADO
        self.logger.info("🔍 === ROUTER - ANÁLISIS DE ESTADO ===")
        self.logger.info(f"📋 _actor_decision: {state.get('_actor_decision')}")
        self.logger.info(f"🎯 _next_actor: {state.get('_next_actor')}")
        self.logger.info(f"⏸️ awaiting_input: {state.get('awaiting_input', False)}")
        self.logger.info(f"👤 datos_usuario_completos: {state.get('datos_usuario_completos', False)}")
        self.logger.info(f"🔄 Execution count: {state.get('_execution_count', 0)}")
        
        # ⭐ PRIORIDAD 1: SEÑALES EXPLÍCITAS DE ACTORES
        actor_decision = state.get("_actor_decision")
        next_actor = state.get("_next_actor")
        
        if actor_decision == "need_input" and next_actor:
            self.logger.info(f"🎭 ACTOR SOLICITA INPUT → {next_actor}")
            # Actualizar estado para indicar que esperamos input
            return "__interrupt__"  # Usar interrupción de LangGraph
        
        if next_actor and actor_decision:
            self.logger.info(f"🎭 ACTOR DECIDIÓ '{actor_decision}' → {next_actor}")
            return next_actor
        
        # ⏸️ PRIORIDAD 2: ESTADO AWAITING_INPUT
        if state.get("awaiting_input", False):
            self.logger.info("⏸️ ESPERANDO INPUT DEL USUARIO → __interrupt__")
            return "__interrupt__"
        
        # 🔼 PRIORIDAD 3: ESCALACIÓN SOLICITADA
        if state.get("escalar_a_supervisor", False):
            self.logger.info("🔼 ESCALACIÓN → escalar_supervisor")
            return "escalar_supervisor"
        
        # 🏁 PRIORIDAD 4: FLUJO COMPLETADO
        if state.get("flujo_completado", False):
            self.logger.info("🏁 FLUJO COMPLETADO → finalizar_ticket")
            return "finalizar_ticket"
        
        # ✅ PRIORIDAD 5: DATOS COMPLETOS
        if state.get("datos_usuario_completos", False):
            incidencia_info = state.get("descripcion_incidencia")
            if incidencia_info:
                self.logger.info("✅ DATOS E INCIDENCIA COMPLETOS → procesar_incidencia")
                return "procesar_incidencia"
            else:
                self.logger.info("✅ DATOS COMPLETOS, FALTAN DETALLES → procesar_incidencia")
                return "procesar_incidencia"
        
        # 🛑 PRIORIDAD 6: PROTECCIÓN ANTI-BUCLE
        execution_count = state.get("_execution_count", 0)
        if execution_count > 10:  # Ajustar límite
            self.logger.warning(f"🛑 BUCLE DETECTADO ({execution_count} ejecuciones) → escalar_supervisor")
            return "escalar_supervisor"
        
        # 🔄 PRIORIDAD 7: ANÁLISIS DE DATOS DE USUARIO
        nombre = state.get("nombre")
        email = state.get("email")
        
        # Si no tenemos datos de usuario básicos
        if not nombre or not email:
            if execution_count < 5:  # Reducir límite para identificación
                self.logger.info(f"👤 FALTAN DATOS DE USUARIO (intento {execution_count}) → identificar_usuario")
                # IMPORTANTE: Incrementar contador para evitar bucles
                state["_execution_count"] = execution_count + 1
                return "identificar_usuario"
            else:
                self.logger.warning(f"🛑 DEMASIADOS INTENTOS IDENTIFICANDO USUARIO → escalar_supervisor")
                return "escalar_supervisor"
        
        # Si tenemos datos básicos pero no están marcados como completos
        if nombre and email and not state.get("datos_usuario_completos", False):
            self.logger.info("🔄 DATOS PRESENTES PERO NO VALIDADOS → identificar_usuario")
            return "identificar_usuario"
        
        # 🎯 DEFAULT FINAL: Procesar incidencia
        self.logger.info("🎯 DEFAULT → procesar_incidencia")
        return "procesar_incidencia"



    def add_conditional_edges(self, graph: StateGraph, source: str, condition_func, path_map: Dict[str, str]):
        """
        Helper para agregar edges condicionales de forma consistente
        
        Args:
            graph: Grafo de LangGraph
            source: Nodo origen
            condition_func: Función de condición (router)
            path_map: Mapeo de destinos posibles
        """
        try:
            graph.add_conditional_edges(
                source,
                condition_func,
                path_map
            )
            self.logger.debug(f"✅ Conditional edges agregados para {source}")
            
        except Exception as e:
            self.logger.error(f"❌ Error agregando conditional edges para {source}: {e}")
            raise
    
    def validate_graph_structure(self) -> bool:
        """
        Validar que la estructura del grafo es correcta
        
        Returns:
            True si el grafo es válido, False en caso contrario
        """
        try:
            # Verificar que todos los destinos de routing existen
            required_nodes = set(self.routing_destinations.values())
            required_nodes.discard(END)  # END es especial
            
            # Aquí podrías agregar más validaciones específicas
            # Por ejemplo, verificar que no hay ciclos infinitos
            
            self.logger.info("✅ Estructura del grafo validada correctamente")
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Error validando estructura del grafo: {e}")
            return False
    
    def get_workflow_metrics(self) -> Dict[str, Any]:
        """
        Obtener métricas del workflow
        
        Returns:
            Diccionario con métricas del workflow
        """
        return {
            "workflow_name": self.name,
            "total_nodes": len(self.routing_destinations) - 1,  # -1 para excluir END
            "decision_nodes": 3,  # identificar_usuario, procesar_incidencia, interrupcion_identificar_usuario
            "terminal_nodes": 2,  # escalar_supervisor, finalizar_ticket
            "interruption_handler": "interrupcion_identificar_usuario",
            "routing_strategy": "centralized_interruptions_with_actor_signals"
        }