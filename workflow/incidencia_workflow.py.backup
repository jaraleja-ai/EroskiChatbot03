# =====================================================
# workflow/incidencia_workflow.py - ROUTER H√çBRIDO ACTUALIZADO
# =====================================================
from langgraph.graph import StateGraph, START, END
from workflow.base_workflow import BaseWorkflow
from models.state import GraphState
from typing import Dict, Any
import logging

# ‚úÖ IMPORTS LIMPIOS - SIN DUPLICACIONES
from nodes.identificar_usuario import identificar_usuario_node
from nodes.procesar_incidencia import procesar_incidencia_node
from nodes.escalar_supervisor import escalar_supervisor_node
from nodes.finalizar_ticket import finalizar_ticket_node
from nodes.recopilar_input_usuario import recopilar_input_usuario

class IncidenciaWorkflow(BaseWorkflow):
    """
    üé≠ WORKFLOW H√çBRIDO ACTUALIZADO: LangGraph + Actor Pattern
    
    NUEVAS CARACTER√çSTICAS:
    - ‚úÖ Interrupciones centralizadas SOLO en recopilar_input_usuario
    - ‚úÖ Router que respeta se√±ales de actores ANTES de decidir
    - ‚úÖ Estado siempre actualizado cuando llega al router
    - ‚úÖ Sin bucles infinitos por dise√±o
    
    PRINCIPIOS H√çBRIDOS:
    - ‚úÖ Estructura LangGraph para el framework
    - ‚úÖ Decisiones aut√≥nomas de actores
    - ‚úÖ Router que RESPETA las se√±ales de actores
    - ‚úÖ Manejo de interrupciones centralizadas
    
    ROUTER INTELIGENTE ACTUALIZADO:
    - Los actores DECIDEN, el router solo EJECUTA
    - Prioriza se√±ales expl√≠citas de actores
    - Centraliza interrupciones en recopilar_input_usuario
    - Fallback inteligente sin bucles
    """
    
    def __init__(self):
        super().__init__("IncidenciaWorkflow")
    
    def build_graph(self) -> StateGraph:
        """Construir grafo h√≠brido con routing inteligente actualizado"""
        
        self.logger.info("üîß Construyendo grafo h√≠brido actualizado...")
        
        # Crear grafo con el estado
        graph = StateGraph(GraphState)
        
        # ‚úÖ AGREGAR TODOS LOS NODOS/ACTORES
        graph.add_node("identificar_usuario", identificar_usuario_node)
        graph.add_node("procesar_incidencia", procesar_incidencia_node) 
        graph.add_node("escalar_supervisor", escalar_supervisor_node)
        graph.add_node("finalizar_ticket", finalizar_ticket_node)
        graph.add_node("recopilar_input_usuario", recopilar_input_usuario)  # ‚≠ê NODO DE INTERRUPCIONES
        
        # Punto de entrada
        graph.add_edge(START, "identificar_usuario")
        
        # ‚úÖ ROUTING H√çBRIDO ACTUALIZADO - INCLUYE recopilar_input_usuario
        self.routing_destinations = {
            "identificar_usuario": "identificar_usuario",
            "procesar_incidencia": "procesar_incidencia",
            "escalar_supervisor": "escalar_supervisor", 
            "finalizar_ticket": "finalizar_ticket",
            "recopilar_input_usuario": "recopilar_input_usuario",  # ‚≠ê INCLUIR EN DESTINOS
            END: END
        }
        
        # ‚úÖ APLICAR ROUTING INTELIGENTE A TODOS LOS ACTORES QUE TOMAN DECISIONES
        decision_actors = [
            "identificar_usuario", 
            "procesar_incidencia", 
            "recopilar_input_usuario"  # ‚≠ê INCLUIR PARA QUE PUEDA DIRIGIR DESPU√âS DE INTERRUPCI√ìN
        ]
        
        for actor_name in decision_actors:
            self.add_conditional_edges(
                graph,
                actor_name,
                self._route_conversation,
                self.routing_destinations
            )
            self.logger.debug(f"üîÄ Routing h√≠brido configurado para {actor_name}")
        
        # ‚úÖ EDGES DIRECTOS PARA NODOS FINALES (sin decisiones complejas)
        graph.add_edge("escalar_supervisor", END)
        graph.add_edge("finalizar_ticket", END)
        
        self.logger.info("‚úÖ Grafo h√≠brido actualizado construido exitosamente")
        return graph
    
    def _route_conversation(self, state: Dict[str, Any]) -> str:
        """
        Router h√≠brido ACTUALIZADO que centraliza interrupciones en recopilar_input_usuario
        
        PRIORIDADES (en orden):
        1. ‚è∏Ô∏è INTERRUPCIONES ‚Üí recopilar_input_usuario (centralizado)
        2. üéØ DECISI√ìN EXPL√çCITA del actor ‚Üí ejecutar
        3. üèÅ FLUJO COMPLETADO ‚Üí END
        4. üîº ESCALACI√ìN ‚Üí escalar_supervisor
        5. ‚úÖ DATOS COMPLETOS ‚Üí procesar_incidencia
        6. üîÑ FALLBACK ‚Üí identificar_usuario
        
        Args:
            state: Estado actual del grafo
            
        Returns:
            Nombre del pr√≥ximo nodo a ejecutar
        """

        # üîç DEBUG COMPLETO AL INICIO
        if self.logger.isEnabledFor(logging.DEBUG):
            self.logger.debug("=" * 60)
            self.logger.debug("üîç ROUTER DEBUG - ESTADO COMPLETO:")
            self.logger.debug(f"üì• _actor_decision: {state.get('_actor_decision')}")
            self.logger.debug(f"üì• requires_user_input: {state.get('requires_user_input')}")
            self.logger.debug(f"üéØ _next_actor: {state.get('_next_actor')}")
            self.logger.debug(f"‚úÖ datos_usuario_completos: {state.get('datos_usuario_completos')}")
            self.logger.debug(f"üë§ nombre: {state.get('nombre')}")
            self.logger.debug(f"üìß email: {state.get('email')}")
            self.logger.debug(f"üîÑ execution_count: {state.get('_execution_count', 0)}")
            self.logger.debug(f"üîº escalar_a_supervisor: {state.get('escalar_a_supervisor')}")
            self.logger.debug(f"üèÅ flujo_completado: {state.get('flujo_completado')}")
            self.logger.debug(f"‚è∏Ô∏è _request_message existe: {bool(state.get('_request_message'))}")
            self.logger.debug(f"üîß _input_context: {state.get('_input_context')}")
            self.logger.debug("=" * 60)

        # ‚è∏Ô∏è PRIORIDAD 1: CENTRALIZAR TODAS LAS INTERRUPCIONES EN recopilar_input_usuario
        if (state.get("requires_user_input", False) or 
            state.get("_actor_decision") == "need_input" or
            state.get("awaiting_input", False) or
            state.get("_request_message")):  # Si hay mensaje espec√≠fico para el usuario
            
            self.logger.info("‚è∏Ô∏è NECESITA INPUT ‚Üí recopilar_input_usuario")
            return "recopilar_input_usuario"
        
        # üéØ PRIORIDAD 2: DECISI√ìN EXPL√çCITA DEL ACTOR (se√±al directa)
        next_actor = state.get("_next_actor")
        if next_actor and next_actor in self.routing_destinations:
            self.logger.info(f"üéØ Actor solicita expl√≠citamente: {next_actor}")
            return next_actor
        
        # üèÅ PRIORIDAD 3: FLUJO COMPLETADO
        if state.get("flujo_completado", False):
            self.logger.info("üèÅ FLUJO COMPLETADO ‚Üí END")
            return END
        
        # üîº PRIORIDAD 4: ESCALACI√ìN A SUPERVISOR
        if state.get("escalar_a_supervisor", False):
            self.logger.info("üîº ESCALACI√ìN ‚Üí escalar_supervisor")
            return "escalar_supervisor"
        
        # ‚úÖ PRIORIDAD 5: DATOS DE USUARIO COMPLETOS ‚Üí PROCESAR INCIDENCIA
        if state.get("datos_usuario_completos", False):
            # Verificar que realmente tengamos los datos
            nombre = state.get("nombre")
            email = state.get("email")
            
            if nombre and email:
                self.logger.info("‚úÖ DATOS COMPLETOS Y VERIFICADOS ‚Üí procesar_incidencia")
                return "procesar_incidencia"
            else:
                self.logger.warning("‚ö†Ô∏è datos_usuario_completos=True pero faltan datos reales")
                # Resetear flag incorrecto y volver a identificar
                return "identificar_usuario"
        
        # üîÑ PRIORIDAD 6: FALLBACK INTELIGENTE
        # Si no hay datos de usuario, volver a identificar
        nombre = state.get("nombre")
        email = state.get("email")
        
        if not nombre or not email:
            self.logger.info("üîÑ FALTAN DATOS DE USUARIO ‚Üí identificar_usuario")
            return "identificar_usuario"
        
        # Si tenemos datos pero no est√°n marcados como completos, procesar
        self.logger.info("üîÑ DATOS DISPONIBLES PERO NO MARCADOS COMPLETOS ‚Üí procesar_incidencia")
        return "procesar_incidencia"
    
    def add_conditional_edges(self, graph: StateGraph, source: str, condition_func, path_map: Dict[str, str]):
        """
        Helper para agregar edges condicionales de forma consistente
        
        Args:
            graph: Grafo de LangGraph
            source: Nodo origen
            condition_func: Funci√≥n de condici√≥n (router)
            path_map: Mapeo de destinos posibles
        """
        try:
            graph.add_conditional_edges(
                source,
                condition_func,
                path_map
            )
            self.logger.debug(f"‚úÖ Conditional edges agregados para {source}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Error agregando conditional edges para {source}: {e}")
            raise
    
    def validate_graph_structure(self) -> bool:
        """
        Validar que la estructura del grafo es correcta
        
        Returns:
            True si el grafo es v√°lido, False en caso contrario
        """
        try:
            # Verificar que todos los destinos de routing existen
            required_nodes = set(self.routing_destinations.values())
            required_nodes.discard(END)  # END es especial
            
            # Aqu√≠ podr√≠as agregar m√°s validaciones espec√≠ficas
            # Por ejemplo, verificar que no hay ciclos infinitos
            
            self.logger.info("‚úÖ Estructura del grafo validada correctamente")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error validando estructura del grafo: {e}")
            return False
    
    def get_workflow_metrics(self) -> Dict[str, Any]:
        """
        Obtener m√©tricas del workflow
        
        Returns:
            Diccionario con m√©tricas del workflow
        """
        return {
            "workflow_name": self.name,
            "total_nodes": len(self.routing_destinations) - 1,  # -1 para excluir END
            "decision_nodes": 3,  # identificar_usuario, procesar_incidencia, recopilar_input_usuario
            "terminal_nodes": 2,  # escalar_supervisor, finalizar_ticket
            "interruption_handler": "recopilar_input_usuario",
            "routing_strategy": "centralized_interruptions_with_actor_signals"
        }